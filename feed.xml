<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://absyun.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://absyun.github.io/" rel="alternate" type="text/html" /><updated>2020-03-18T19:27:20+09:00</updated><id>https://absyun.github.io/feed.xml</id><title type="html">별거있나</title><entry><title type="html">OIDC Login 구현해보기 Part-1</title><link href="https://absyun.github.io/development/2020/03/18/01.html" rel="alternate" type="text/html" title="OIDC Login 구현해보기 Part-1" /><published>2020-03-18T11:15:00+09:00</published><updated>2020-03-18T11:15:00+09:00</updated><id>https://absyun.github.io/development/2020/03/18/01</id><content type="html" xml:base="https://absyun.github.io/development/2020/03/18/01.html">&lt;h1 id=&quot;oidc&quot;&gt;OIDC…&lt;/h1&gt;

&lt;p&gt;Open ID Connect 일명 OIDC … 요즘 많은 사이트에서 볼 수 있는, 카카오, 네이버 로그인, 페이스북, 구글 계정 등으로 로그인과 같이 서비스를 제공해주는 측에서는 민감한 사용자의 개인정보 (아이디, 패스워드등)을 회원가입을 통해 수집/보관하지 않고 사용자를 인증하는 과정을 Provider측에 위임하는 형태의 서비스를 많이 볼 수 있다.
이는 사용자 입장에서도 불필요하게 작은 사이트에도 회원가입을 일일이 해야하는 수고로움을 덜어주는 좋은 방향인 듯 하다.
Provider 측에서는 사용자가 접속하는 서버의 정보들을 다 수집할 수 있긴하겠지만…&lt;/p&gt;

&lt;p&gt;사실 OIDC 이전에 SAML 2.0, OAuth 2.0 등의 IDP(IDentity Provider)도 있지만, 가장 최근에 정의된 OIDC에 대해서 좀 더 관심이 갔기에 해당 로그인 방식을 살펴보고 샘플로 구현해보자 한다.&lt;/p&gt;

&lt;h2 id=&quot;provider---keycloak-설정&quot;&gt;Provider - Keycloak 설정&lt;/h2&gt;

&lt;p&gt;우선 로그인을 구현할 Provider를 선정해야하는 데… 실제로 서비스하는 Provider가 아닌 Provider 또한 컨트롤이 가능한 Keycloak이라는 툴을 Local에 설치하여 테스트하며 사용하기로 한다.&lt;/p&gt;

&lt;p&gt;Keycloak은 Docker 이미지로 바로 Bootup이 가능하기 때문에 굉장히 편리하게 Local setup이 가능하다.
[참고] https://hub.docker.com/r/jboss/keycloak/&lt;/p&gt;

&lt;p&gt;일단 Keycloak은 실 목적을 달성하기 위한 툴에 불과하므로 부가 설명은 생략하고… 요약하면 아래와 같은 명령어로 금방 띄울 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Container로 띄우기
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 8080:8080 jboss/keycloak
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;ps명령어로 CONTAINER ID 확인 후 Admin account 생성, Restart&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker ps
docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &amp;lt;CONTAINER&amp;gt; /opt/jboss/keycloak/bin/add-user-keycloak.sh &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; &amp;lt;USERNAME&amp;gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &amp;lt;PASSWORD&amp;gt;
docker restart &amp;lt;CONTAINER&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;../assets/2020-03-18-01/1.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정상적으로 수행되었다면 [http://localhost:8080/]로 접속시 Keycloak이 동작됨을 확인할 수 있다.
Administration Consle을 통해 입력한 USERNAME, PASSWORD로 로그인하게 되면 메인화면이 나타난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/2020-03-18-01/2.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 Keycloak 측 Provider 세팅을 완료하도록 하자…
Realm(Realm 하나가 하나의 IDP 라고 가볍게 생각할 수 있다.)은 Master로 두도록 하고 여기에 앞으로 우리가 접속할 Client를 등록하고 ID를 발급받도록 하자.
실제로 다른 IDP서비스에 인증을 제공받기 위해 등록시에도 동일한 절차를 거칠 것이다.&lt;/p&gt;

&lt;p&gt;Clients로 가서 Create를 하자. Client ID는 가볍게 “oidc-test”, Protocal은 구현해볼 openid-connect로 설정한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/2020-03-18-01/3.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;여기서-초기설정시-결정해야할-타입이-하나-있다&quot;&gt;여기서 초기설정시 결정해야할 타입이 하나 있다.&lt;/h3&gt;
&lt;p&gt;참고 [https://www.keycloak.org/docs/4.8/server_admin/]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;access-type&quot;&gt;Access Type&lt;/h4&gt;

  &lt;p&gt;This defines the type of the OIDC client.&lt;/p&gt;

  &lt;p&gt;&lt;b&gt;confidential&lt;/b&gt;
Confidential access type is for server-side clients that need to perform a browser login and require a client secret when they turn an access code into an access token, (see Access Token Request in the OAuth 2.0 spec for more details). This type should be used for server-side applications.&lt;/p&gt;

  &lt;p&gt;&lt;b&gt;public&lt;/b&gt;
Public access type is for client-side clients that need to perform a browser login. With a client-side application there is no way to keep a secret safe. Instead it is very important to restrict access by configuring correct redirect URIs for the client.&lt;/p&gt;

  &lt;p&gt;&lt;b&gt;bearer-only&lt;/b&gt;
Bearer-only access type means that the application only allows bearer token requests. If this is turned on, this application cannot participate in browser logins.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Keycloak 사이트에서 설명해놓은 설정이다.&lt;/p&gt;

&lt;p&gt;여기서 필자는 Confidential 타입으로 구현해볼 것이다.&lt;/p&gt;

&lt;p&gt;가이드에 나와있는 것 처럼, 웹사이트에서의 OIDC client를 구현할 예정이기에 해당 타입이 적절하다 판단된다. 순수 App client에서의 동작이더라도, Backend가 있다면 Confidential이 더 보안측면에서는 한결 더 유리하지 않을까 싶다. Confidentail 타입은 IDP가 제공해주는 Secret key가 없다면 아예 토큰자체를 받을 수 없는 구조이기 때문이다.&lt;/p&gt;

&lt;p&gt;그 다음 필수로 Redirect Url을 입력해야한다. 인증과정에서 IDP가 인증 완료 후 다시 요청해온 웹사이트로 Redirection을 해주게 되는 데, 이 장치로 인해 내가 등록한 Client 외의 다른 임의의 사이트가 이 ClientID를 사용할 수 없게 된다.
등록한 Client는 로그인 후 무조건 인가된 사이트로만 Code등을 전달해주기 때문이다.&lt;/p&gt;

&lt;p&gt;여기서는 간단히 로컬에서 모든 걸 다 진행할 예정이기에 http://localhost/* 로 입력해두자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/2020-03-18-01/4.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 만든 Client Id와 앞으로 사용할 Secret을 확인해두자.&lt;/p&gt;

&lt;p&gt;자, 이제 기본 Keycloak 및 기본 준비는 끝난 것 같다.&lt;/p&gt;

&lt;p&gt;다음 Part 부터 본격적으로 로그인 구현을 해볼 예정이다.&lt;/p&gt;</content><author><name></name></author><summary type="html">OIDC…</summary></entry><entry><title type="html">Windows 10 WSL</title><link href="https://absyun.github.io/environment/2020/03/15/01.html" rel="alternate" type="text/html" title="Windows 10 WSL" /><published>2020-03-15T12:57:43+09:00</published><updated>2020-03-15T12:57:43+09:00</updated><id>https://absyun.github.io/environment/2020/03/15/01</id><content type="html" xml:base="https://absyun.github.io/environment/2020/03/15/01.html">&lt;h1 id=&quot;wsl-windows-subsystem-for-linux&quot;&gt;WSL (Windows Subsystem for Linux)&lt;/h1&gt;

&lt;p&gt;Microsoft에서 Windows PC로 더 훌륭한 개발경험을 제공해주기 위해 내놓은 시스템이다. 익숙해지면 Mac이 아쉬워지지 않을까… 개인적으로 단일 디바이스를 선호하는 데, Windows는 여러 이유로 포기하기가 어려웠던 터라 이 기능이 기대되지 않을 수 없었다.&lt;/p&gt;

&lt;h4 id=&quot;microsoft에서-공개한-아키텍쳐&quot;&gt;Microsoft에서 공개한 아키텍쳐&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-01/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/&quot;&gt;https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;설치-방법&quot;&gt;설치 방법&lt;/h2&gt;

&lt;p&gt;우선 제어판에서 Linux용 하위 시스템 Option을 켜줘야하며,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;제어판 -&amp;gt; 프로그램 및 기능 -&amp;gt; Windows 기능 켜기/끄기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-01/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래 존재하는 리스트 중 WSL으로 사용할 원하는 Linux 배포판을 설치해 줘야한다. 일반적으로 Microsoft store에서 찾아서 설치를 진행하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disto list&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-01/2-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치가 완료되면 일반 Window용 Program 처럼 실행이 가능(Debian 계열이 익숙하기에 Ubuntu를 설치했다.)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-01/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-01/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 실행시 일부 설정을 완료하면 아래와 같이 Terminal이 실행된다. 이미 Shell 설정을 한 상태라 순정인 이미지는 아니지만.. (참고차.. 기록)&lt;/p&gt;

&lt;p&gt;과거에 Windows에서 Git을 사용하기 위해, 또 터미널을 사용하기 위해 개인적으로 UX등이 마음에 들진 않지만 불가피하게 별도의 프로그램 등을 설치하여 사용했지만 이제는 Linux 기분을 느끼게 해주는 Terminal 에서&lt;br /&gt;
Lunix용 툴들을 설치해가며 신세계를 경험할 수 있다.!&lt;/p&gt;</content><author><name></name></author><summary type="html">WSL (Windows Subsystem for Linux)</summary></entry><entry><title type="html">Github sshkey로 계정 연결하기</title><link href="https://absyun.github.io/environment/2020/03/15/02.html" rel="alternate" type="text/html" title="Github sshkey로 계정 연결하기" /><published>2020-03-15T12:57:43+09:00</published><updated>2020-03-15T12:57:43+09:00</updated><id>https://absyun.github.io/environment/2020/03/15/02</id><content type="html" xml:base="https://absyun.github.io/environment/2020/03/15/02.html">&lt;h1 id=&quot;github-sshkey로-계정-연결하기&quot;&gt;Github sshkey로 계정 연결하기&lt;/h1&gt;

&lt;p&gt;SSH-key를 이용해서 git-repo 사용하기…&lt;/p&gt;

&lt;p&gt;Github을 사용하다보면 보면 username, password를 계속 입력하기 싫어서 config에 Setting하게 되는 데, 이보다 더 안정적으로 매번 password를 입력하는 불편함 없이 사용하기 위해 ssh-key를 이용해서 설정하는 방법을 기록해둔다.&lt;/p&gt;

&lt;h3 id=&quot;ssh-key-생성&quot;&gt;ssh-key 생성&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$&amp;gt;&lt;/span&gt; ssh-keygen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령을 수행하면 Key이름을 설정할 수 있고 (하지 않을 경우 id_rsa로 생성) passphrase &lt;a href=&quot;https://www.ssh.com/ssh/passphrase&quot;&gt;https://www.ssh.com/ssh/passphrase&lt;/a&gt;는 private key의 유출 및 탈취 상황을 대비하기 위해 encryption 하는 방식인데, 여기선 입력하지 않는 걸로…&lt;br /&gt;
키를 생성하게 되면 $HOME 밑에 .ssh/ 아래에 id_rsa, id_rsa.pub (다른 이름을 입력했을 경우 해당 이름) 키가 생성된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-02/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성된 Public key, Private key는 항상 세트로 움직여야하고&lt;br /&gt;
Public key는 이름 답게 외부에 Open하는 키 이다. SSH로 접속할 서버에 보통 등록을 해두게 되고, 그에 대응하는 Private key는 절대 유출되어서는 안되며, Public key를 등록해놓은 곳에 접속할 때 자신을 인증하는 용도로 사용되어 진다.&lt;/p&gt;

&lt;p&gt;그럼 이제 이 Public key를 Github에 먼저 등록하러 가보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;github에-public-key-등록하기&quot;&gt;Github에 Public key 등록하기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-02/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 계정내 Settings로 진입하게 되면 “SSH and GPG Keys”&lt;br /&gt;
에서 New SSH key를 입력한다음, Public key의 내용을 복사해서 입력하면 된다.&lt;/p&gt;

&lt;p&gt;cat ./id_rsa.pub&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;등록된 상태&lt;br /&gt;
&lt;img src=&quot;/assets/2020-03-15-02/3.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ssh-config-설정&quot;&gt;ssh config 설정&lt;/h2&gt;

&lt;p&gt;$HOME 아래에 .ssh directory 밑에 config파일 설정을 해야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host github.com
HostName github.com
User Username
IdentityFile /home/someuser/.ssh/id_rsa

Host github.com
HostName github.com
User Username2
IdentityFile /home/someuser/.ssh/id2_rsa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 설정하게 되면 ssh로 github.com 도메인으로 접속할 경우&lt;br /&gt;
설정된 IdentitiFile (key)와 User ID를 이용해서 로그인을 하게 된다. 보는 바와 같이 Username을 다르게 해서 User에 따라 키를 다르게 사용할 수도 있고, Repo를 Github, Gitlab 어느 host로 접속하게 되는 가에 따라 다른 키를 자동으로 매핑되도록 관리해줄 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;git-repo&quot;&gt;Git repo&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-02/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git에서 Repo를 Clone할때 SSH를 이용해서 Clone을 하자.&lt;br /&gt;
Clone 후 해당 Repo에 .git/config 파일을 살펴보면,&lt;br /&gt;
[remote] 에 https로 되어있으면, push를 할 때 ssh로 설정으로 동작되지 않을 수 있기 때문에 ssh 주소를 사용하자,&lt;br /&gt;
참고로 ssh config에 Multiuser를 설정해 놓을 경우 각 Repo 안에 어떤 User의 정보를 사용할지를 판단할 수 있는 정보가 들어있다.&lt;/p&gt;

&lt;h3 id=&quot;이제-password-입력-불편함-없이-사용하면-된다&quot;&gt;이제 Password 입력 불편함 없이 사용하면 된다.!&lt;/h3&gt;</content><author><name></name></author><summary type="html">Github sshkey로 계정 연결하기</summary></entry><entry><title type="html">Visual studio code + WSL</title><link href="https://absyun.github.io/environment/2020/03/15/03.html" rel="alternate" type="text/html" title="Visual studio code + WSL" /><published>2020-03-15T12:57:43+09:00</published><updated>2020-03-15T12:57:43+09:00</updated><id>https://absyun.github.io/environment/2020/03/15/03</id><content type="html" xml:base="https://absyun.github.io/environment/2020/03/15/03.html">&lt;p&gt;Windows 10 바탕에 WSL 기반으로 개발 환경을 셋팅하고, 본격적 사용을 하다보면 불편한 점이 바로 나타난다.&lt;/p&gt;

&lt;p&gt;Linux 환경에서의 GUI 환경 부재다. 물론 vi 로 “모든 걸 다 할 수 있어!” 라고 주장하시는 분들이라면 뭐… 딱히 공감을 못할지도 모르겠지만, 자고로… 개발자들은 기술, 문명의 발전… 을 흡수할 수도 있어야하는 것이 아닌가 라는 측면에서 필자는 새로운 Tool들의 장점… 그로부터 오는 생산성을 받아들어야한다고 생각하는 입장이다.&lt;/p&gt;

&lt;p&gt;당장 GUI가 되지 않으면 바로 IDE 사용이 힘들어진다.&lt;/p&gt;

&lt;p&gt;Windows 환경에서 동작하는 IDE는 기본적으로 WSL상의 File system에서 기본적으로 접근이 되지 않는 것이 문제이다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 몇가지 시도를 해보았고, 그 내용을 공유하고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-xming의-이용&quot;&gt;1. Xming의 이용&lt;/h2&gt;

&lt;p&gt;디스플레이 서버를 이용해서 Linux terminal에서 GUI 프로그램을 실행하게 되면, Windows 측에서 창을 하나 띄워주는 방법이 있다. 하지만 이는 해상도나 성능면에서 개인적으로 만족스럽지 못했다. 환경을 구성했다가 만족 못했기에 특별히 기록을 남기진 않았지만… 필요하신 분은 구글링을 통하면 쉽게 구축이 가능하실 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-wsl에서-windows-폴더에-접근해서-사용하는-방식&quot;&gt;2. WSL에서 Windows 폴더에 접근해서 사용하는 방식&lt;/h2&gt;

&lt;p&gt;Windows file system에서 workspace를 하나 만들고,WSL에서 이에 접근(/mnt/c)이 가능하므로 여기서 Linux 관련 명령(Git이나 빌드)를 수행한다. 해당 Directory는 Windows file system에 존재하기에 Windows용 IDE 역시 접근이 가능하다.&lt;br /&gt;
다만 실제로 사용해보면 파일 권한 문제등으로 인해 WSL에서의 사용이 불만족스러웠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-visual-studio-code-plugin-활용&quot;&gt;3. Visual studio code plugin 활용&lt;/h2&gt;

&lt;p&gt;실제로 VSCODE를 사용하지 않는 사람에게는 의미 없는 방법일 수 있지만, 주력 IDE로 사용하는 필자에게는 최고의 Plugin 중 하나이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-03/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치를 하게 되면 왼쪽 하단에 초록색 아이콘을 클릭하게 되면 WSL 모드로 VSCODE를 실행 시킬 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WSL 모드로 실행되면 왼쪽 아래와 같이 표시
&lt;img src=&quot;/assets/2020-03-15-03/2.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 Folder를 open하게 되면 기존과 달리 Windows의 탐색기 창이 뜨지 않고, 아래와 같이 WSL 내부 Directory 구조가 나타나고 원하는 위치의 파일을 열 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-03/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;추가로 VSCODE 내부의 터미널 또한… WSL 기반의 터미널로 동작하게 된다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-03/4.png&quot; alt=&quot;&quot; /&gt;
더이상 Mac이 부럽지 않다 ㅠㅠ&lt;/p&gt;</content><author><name></name></author><summary type="html">Windows 10 바탕에 WSL 기반으로 개발 환경을 셋팅하고, 본격적 사용을 하다보면 불편한 점이 바로 나타난다.</summary></entry><entry><title type="html">WSL2 … and Docker</title><link href="https://absyun.github.io/environment/2020/03/15/04.html" rel="alternate" type="text/html" title="WSL2 ... and Docker" /><published>2020-03-15T12:57:43+09:00</published><updated>2020-03-15T12:57:43+09:00</updated><id>https://absyun.github.io/environment/2020/03/15/04</id><content type="html" xml:base="https://absyun.github.io/environment/2020/03/15/04.html">&lt;p&gt;WSL + VSCODE의 조합으로 많은 것들을 편리한 환경에서 수행해 올 수 있었다. 하지만 WSL에서 아쉬움으로 와 닿았던 것… 바로 Docker 실행이다. 초반에는 Docker를 포기하고 준비된 환경안에서 할 수 있는 것들에 만족해 왔지만…&lt;/p&gt;

&lt;p&gt;어느 순간 Docker가 절실히 필요해진 상황이왔고… 이를 해결하기 위해 WSL2로 Windows10을 테스트 버전 업그레이드를 강행하게 되었다.&lt;br /&gt;
참고로 불안정하다고 누누이 경고하고 있기에 필자처럼 성격급한 사람이 아니라면 정중히 말리고싶다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;wsl2&quot;&gt;WSL2&lt;/h2&gt;

&lt;p&gt;WSL1 대비해서 기본 아키텍쳐가 가상머신을 활용하는 구조였고, File IO 성능면에서 아쉬운 점이 많았다고 한다.&lt;br /&gt;
(소규모 Build만 수행해봤기에.. 큰 불편은 못느꼈던 1인..)&lt;br /&gt;
아마.. 20년에 정식 릴리즈 되게될 WSL2는 아예 Windows용 Linux 커널을 새로 만들고 Hyper-v 기반으로 변경되어 WSL1 대비 성능이 좋아진다고 한다. 특히 Docker가 native 형태로 정식지원이 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;windows-10-업그레이드&quot;&gt;Windows 10 업그레이드&lt;/h2&gt;

&lt;p&gt;현시점에선 Windows 버전이 정식 Release버전이 아닌 Insider Preview 버전을 설치해야한다.&lt;br /&gt;
설정에 들어가서 Windows 참가자 프로그램에 가입한 다음 WIndows를 업데이트 해주자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-04/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;업데이트 후 cmd창에서 ver을 입력하면 Windows build 번호를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-04/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;바이너리-직접-설치&quot;&gt;바이너리 직접 설치&lt;/h2&gt;

&lt;p&gt;18917 버전 이상만이 WSL2 사용이 가능하다. 어떤 이유에서인지 필자의 경우 참가자 프로그램 가입만으로는 해당 버전으로 올라가지 않아, 찾아보니 19041 버전이 조만간 정식 릴리즈 예정인지 Binary자체가 풀려있었다.&lt;/p&gt;

&lt;p&gt;Preview insider라면 직접 다운받아서 설치가 가능하다.[&lt;a href=&quot;https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewadvanced&quot;&gt;Download page&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;wsl2-설치&quot;&gt;WSL2 설치&lt;/h2&gt;

&lt;p&gt;Windows 설치 후 &lt;a href=&quot;https://docs.microsoft.com/ko-kr/windows/wsl/wsl2-install&quot;&gt;[WSL 2 설치 가이드]&lt;/a&gt; 에 안내되어있는 Command를 차례로 수행해나가면 WSL2 설치는 끝이난다.&lt;/p&gt;

&lt;p&gt;설치가 정상적으로 되었다면 사용하는 Diastro가 version 2가 된 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-04/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;docker-desktop-설치&quot;&gt;Docker desktop 설치&lt;/h2&gt;

&lt;p&gt;이제 Windows용 Docker Desktop을 설치할 차례다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-04/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정식 사이트에서 그냥 다운 받아서 설치하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Resource에 WSL INTEGRATION 메뉴에 체크를 해주게 되면, &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-03-15-04/5.png&quot; alt=&quot;&quot; /&gt;
docker.sock … 드디어 나왔다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 일반 Linux 환경에서 Docker를 사용하는 것 처럼 그냥 사용하면 된다.!&lt;/p&gt;</content><author><name></name></author><summary type="html">WSL + VSCODE의 조합으로 많은 것들을 편리한 환경에서 수행해 올 수 있었다. 하지만 WSL에서 아쉬움으로 와 닿았던 것… 바로 Docker 실행이다. 초반에는 Docker를 포기하고 준비된 환경안에서 할 수 있는 것들에 만족해 왔지만…</summary></entry></feed>